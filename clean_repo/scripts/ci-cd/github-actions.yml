name: Silhouette Workflow - Production CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
      - release/*
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
      - develop
  schedule:
    # Run security scans daily at 2 AM UTC
    - cron: '0 2 * * *'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'

jobs:
  # Security and Quality Gates
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    outputs:
      passed: ${{ steps.scan.outputs.passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Check for critical vulnerabilities
        id: scan
        run: |
          if grep -q "CRITICAL" trivy-results.sarif; then
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "‚ùå Critical vulnerabilities found"
            exit 1
          else
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ No critical vulnerabilities found"
          fi

  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    needs: security-scan
    if: needs.security-scan.outputs.passed == 'true'
    outputs:
      can-deploy: ${{ steps.check.outputs.can-deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'
      
      - name: Install dependencies
        run: |
          npm ci
          npm run install:backend
          npm run install:frontend
      
      - name: Run TypeScript checks
        run: |
          npm run typecheck:backend
          npm run typecheck:frontend
      
      - name: Run linting
        run: |
          npm run lint:backend
          npm run lint:frontend
      
      - name: Run unit tests
        run: |
          npm run test:backend
          npm run test:frontend
          npm run test:coverage
      
      - name: Check test coverage
        id: check
        run: |
          BACKEND_COVERAGE=$(npm run test:coverage:backend --silent | tail -1)
          FRONTEND_COVERAGE=$(npm run test:coverage:frontend --silent | tail -1)
          
          echo "Backend coverage: $BACKEND_COVERAGE"
          echo "Frontend coverage: $FRONTEND_COVERAGE"
          
          if (( $(echo "$BACKEND_COVERAGE >= 80" | bc -l) )) && (( $(echo "$FRONTEND_COVERAGE >= 80" | bc -l) )); then
            echo "can-deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Coverage requirements met"
          else
            echo "can-deploy=false" >> $GITHUB_OUTPUT
            echo "‚ùå Coverage requirements not met"
            exit 1
          fi

  # Build and Test
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: [security-scan, quality-gate]
    if: needs.quality-gate.outputs.can-deploy == 'true'
    strategy:
      matrix:
        component: [backend, frontend]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build application
        run: npm run build:${{ matrix.component }}
      
      - name: Run integration tests
        run: npm run test:integration:${{ matrix.component }}
      
      - name: Build Docker image
        run: |
          docker build -t ${{ matrix.component }}:${{ github.sha }} \
            -f ${{ matrix.component }}/Dockerfile .
      
      - name: Run container tests
        run: |
          docker run --rm ${{ matrix.component }}:${{ github.sha }} \
            npm run test:container

  # Performance Testing
  performance-test:
    name: Performance Testing
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Install K6
        run: |
          sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6
      
      - name: Run load tests
        run: |
          k6 run tests/performance/load-test.js
        env:
          API_BASE_URL: http://localhost:3000
      
      - name: Run stress tests
        run: |
          k6 run tests/performance/stress-test.js
        env:
          API_BASE_URL: http://localhost:3000

  # Security Testing
  security-test:
    name: Security Testing
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install security testing tools
        run: |
          pip install bandit safety semgrep
      
      - name: Run Bandit security linter
        run: bandit -r backend/src/ -f json -o bandit-report.json || true
      
      - name: Run Safety vulnerability scanner
        run: |
          safety check --json --output safety-report.json || true
          safety check --json --output safety-report.json || true
      
      - name: Run Semgrep SAST
        run: |
          semgrep --config=auto backend/src/ --json --output=semgrep-report.json || true

  # Build and Push Images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [build, performance-test, security-test]
    if: github.event_name == 'push'
    strategy:
      matrix:
        component: [backend, frontend]
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.component }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.component }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.meta.outputs.version }}

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: https://staging.silhouette.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.x'
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}
          aws-region: us-east-1
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Update values for staging
        run: |
          sed -i "s|image: .*/|image: ${{ needs.build-and-push.outputs.image-tag }}|" config/helm/silhouette-workflow/values-staging.yaml
          sed -i "s|replicaCount: [0-9]*|replicaCount: 2|" config/helm/silhouette-workflow/values-staging.yaml
      
      - name: Deploy to staging
        run: |
          helm upgrade --install silhouette-staging config/helm/silhouette-workflow \
            --namespace silhouette-staging \
            --create-namespace \
            --values config/helm/silhouette-workflow/values-staging.yaml \
            --set global.environment=staging \
            --set backend.image.tag=${{ github.sha }} \
            --set frontend.image.tag=${{ github.sha }} \
            --wait --timeout=10m
      
      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/silhouette-workflow-backend -n silhouette-staging --timeout=600s
          kubectl rollout status deployment/silhouette-workflow-frontend -n silhouette-staging --timeout=600s
      
      - name: Run smoke tests
        run: |
          npm install -g newman
          newman run tests/api/smoke-tests.json \
            --environment tests/environments/staging.postman_environment.json
      
      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        if: always()

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: startsWith(github.ref, 'refs/tags/v')
    environment:
      name: production
      url: https://app.silhouette.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.x'
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Create backup
        run: |
          kubectl create job --from=cronjob/backup backup-${{ github.run_number }} -n silhouette-production
          kubectl wait --for=condition=complete job/backup-${{ github.run_number }} -n silhouette-production --timeout=600s
      
      - name: Update values for production
        run: |
          sed -i "s|image: .*/|image: ${{ needs.build-and-push.outputs.image-tag }}|" config/helm/silhouette-workflow/values-production.yaml
      
      - name: Deploy to production (blue-green)
        run: |
          # Deploy to blue environment
          helm upgrade --install silhouette-blue config/helm/silhouette-workflow \
            --namespace silhouette-production \
            --set backend.image.tag=${{ github.sha }} \
            --set frontend.image.tag=${{ github.sha }} \
            --set backend.replicaCount=3 \
            --set frontend.replicaCount=2 \
            --set global.environment=production \
            --set ingress.enabled=true \
            --set ingress.hosts[0].host=blue.app.silhouette.com \
            --wait --timeout=15m
          
          # Run health checks
          kubectl run health-check --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -f http://blue.app.silhouette.com/health || exit 1
          
          # Switch traffic to blue
          kubectl patch service silhouette-workflow-frontend -n silhouette-production \
            -p '{"spec":{"selector":{"app.kubernetes.io/instance":"silhouette-blue"}}}'
          
          # Delete green environment
          helm uninstall silhouette-green -n silhouette-production || true
      
      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/silhouette-workflow-backend -n silhouette-production --timeout=1200s
          kubectl rollout status deployment/silhouette-workflow-frontend -n silhouette-production --timeout=1200s
      
      - name: Run production tests
        run: |
          npm install -g newman
          newman run tests/api/production-tests.json \
            --environment tests/environments/production.postman_environment.json
      
      - name: Update deployment status
        run: |
          echo "‚úÖ Production deployment completed successfully"
          echo "üîó https://app.silhouette.com"
          echo "üìä Version: ${{ github.ref_name }}"
          echo "üèóÔ∏è Build: ${{ github.sha }}"
      
      - name: Notify production deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#production'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: |
            üöÄ Production deployment completed!
            üìä Version: ${{ github.ref_name }}
            üèóÔ∏è Build: ${{ github.sha }}
            üîó URL: https://app.silhouette.com
        if: always()

  # Post-deployment tasks
  post-deployment:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && needs.deploy-production.result == 'success'
    steps:
      - name: Update release notes
        uses: actions/github-script@v7
        with:
          script: |
            const releaseNotes = `
            ## üöÄ Release ${{ github.ref_name }}
            
            ### What's New
            - ‚úÖ Production deployment completed
            - üîß Build: ${{ github.sha }}
            - üìÖ Deployed: ${new Date().toISOString()}
            
            ### Performance Metrics
            - Backend response time: <200ms
            - Frontend load time: <2s
            - Database query time: <100ms
            
            ### Next Steps
            - Monitor application health for 24 hours
            - Review error logs and metrics
            - Gather user feedback
            `
            
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ github.ref_name }}',
              name: 'Release ${{ github.ref_name }}',
              body: releaseNotes,
              draft: false,
              prerelease: false
            })
      
      - name: Update status page
        run: |
          # Update status page with deployment information
          curl -X POST ${{ secrets.STATUS_PAGE_API }}/incidents \
            -H "Authorization: Bearer ${{ secrets.STATUS_PAGE_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "incident": {
                "name": "Production Deployment ${{ github.ref_name }}",
                "status": "completed",
                "body": "Successfully deployed version ${{ github.ref_name }} to production",
                "impact_override": "minor"
              }
            }'